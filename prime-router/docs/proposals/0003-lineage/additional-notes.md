## Additional notes as the code was developed

### ACTIONs

The ACTION table is strictly a record of an action that has already occurred.  It is meant to be immutable - no updates. 

My current plan is that we'll have separate table, NEXT_ACTION or maybe TODO, that will take the role currently played by the TASK table.   Then we can simply leave the TASK table in the database, not used, so we have that history.   If needed, that history can be migrated to the new tables.

You could argue that ACTION should be renamed ACTION_HIST.  

### REPORT_FILE

Every report in the database must be generated by an action.

The initial `receive` action does quite a lot:  it generates both the incoming file, and the transformed reports for each future receiver as well.

I considered naming this table REPORT_HIST instead of REPORT_FILE, and making it immutable.  I can think of a couple reasons not to do this:
1. Bad data.   If the system generates erroneous data, you need a way to mark that data as bad.
2. The WIPE action - I feel like if you wipe a report from the system, the REPORT_FILE table should be updated to reflect that the data no longer exists.
One option would be to implement triggers that prevent updates except for a status field.  Note:  the report_file table currently has no status field.

### REPORT_LINEAGE

This simple parent/child table should also be immutable.

### ITEM Tracking (Coming soon)

To ensure that items can be uniquely tracked, we make the following key assumption:

We assume that within any one report, the index ordering (eg, 1,2,3,...) and number of Items is fixed. That is, we can write a Report to a blob store, and read it back into memory later, and be certain that the order of the Items and the number of Items has not changed.   This simple assumption means our code can guarantee unique Item lineage tracking, because (item_index, report_id) is now a system-wide unique key for each Item.   When we read data from the blob store, we now have a simple way to match Items in the data blob to corresponding items tracked in our lineage database tables.

Note that other options are not as good:
- use the sending customer's trackingElement (bad: might not be unique, and doubly bad because it requires the send step to parse hl7, csv, and redox), or
- attaching our own additional unique id into the blob data (bad: the downstream receiving customer doesn't want our ids in their data)


### Notes on ITEM tracking in each of the main azure functions:

tbd